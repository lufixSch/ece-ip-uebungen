{"0": {
    "doc": "Übung 1 - Sonderzeichen",
    "title": "Übung 1 - Sonderzeichen",
    "content": "Hey ",
    "url": "/ece-ip-uebungen/ip1/sonderzeichen/",
    "relUrl": "/ip1/sonderzeichen/"
  },"1": {
    "doc": "Übung 2 - Datum und Uhrzeit",
    "title": "Übung 2 - Datum und Uhrzeit",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/datum-uhrzeit/",
    "relUrl": "/ip1/datum-uhrzeit/"
  },"2": {
    "doc": "Übung 3 - Funktionen und Operatoren - Binäre Darstellung",
    "title": "Übung 3 - Funktionen und Operatoren - Binäre Darstellung",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/binaere-darstellung/",
    "relUrl": "/ip1/binaere-darstellung/"
  },"3": {
    "doc": "Übung 4 - Mittelwertbildung",
    "title": "Übung 4 - Mittelwertbildung",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/mittelwertbildung/",
    "relUrl": "/ip1/mittelwertbildung/"
  },"4": {
    "doc": "Übung 5 - Arduino Übung - Blink",
    "title": "Übung 5 - Arduino Übung - Blink",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/blink/",
    "relUrl": "/ip1/blink/"
  },"5": {
    "doc": "Übung 6 - Arduino Übung - Parksensor",
    "title": "Übung 6 - Arduino Übung - Parksensor",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/parksensor/",
    "relUrl": "/ip1/parksensor/"
  },"6": {
    "doc": "Übung 7 - Arduino Übung - Rollosteuerung",
    "title": "Übung 7 - Arduino Übung - Rollosteuerung",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/rollosteuerung/",
    "relUrl": "/ip1/rollosteuerung/"
  },"7": {
    "doc": "Übung 8 - Filter",
    "title": "Übung 8 - Filter",
    "content": "# Übung 8 - Filter ## Übungsinhalte - Arrays - Kontrollstrukturen - Tastatureingabe - lesen aus einer Datei und schreiben in eine Datei - Coding Style ## Begriffe in diesem Zusammenhang Abtasttheorem nach Shannon, Filterkern, Faltung, Glättung ... ## Aufgabenstellung Schreiben Sie ein Programm, das Daten aus einem File einliest und anschließend filtert und wieder ausgibt. Bei den Daten handelt es sich um 640 char-Zahlenwerte, die einen \"verrauschten\" sinusförmigen Verlauf darstellen. (siehe „sinus-6.txt“) Nach Einlesen der Daten soll der Benutzer aufgefordert werden, eine Filterbreite einzugeben. Die Filterbreite repräsentiert die Anzahl der Werte, über die jeweils gleitend der Mittelwert gebildet wird. Gültige Werte für die Filterbreite sind von 1 bis 64. Analysieren Sie die Auswirkung verschiedener Filterbreiten, in dem Sie die gefilterten Daten in Excel visualisieren. Dokumentieren Sie ihre Erkenntnisse und begründen Sie. [zu filternde Rohdaten](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/08-filter) ## Detailanforderungen - Das Programm soll bei Start eine Beschreibung ausgeben, was vom Benutzer erwartet wird und was das Programm tun wird - Vom Benutzer eingegebener Text wird ausgewertet. Wenn es sich um eine Zahl handelt, muss der „Zahlentext“ in eine Zahl umgewandelt werden. Die eingegebene Zahl stellt die zu verwendende Filterbreite dar. Prüfen Sie den eingegebenen Wert auf Plausibilität (gültige Werte: 1 bis 64) - Filtern Sie die Daten durch Faltung mit dem besprochenen Filterkern - Schreiben Sie die gefilterten Daten in eine Datei, die Sie in Excel importieren/öffnen können (.csv) - vergleichen Sie das Ergebnis verschiedener Filterbreiten und stellen Sie diese grafisch in einem Excel Dokument dar - Beschreiben Sie Ihre Beobachtungen im Excel Dokument - welcher Filter liefert einen sauberen Sinusverlauf in den gefilterten Daten - Was beobachten Sie in den gefilterten Daten mit steigender Filterbreite und warum? (Amplitude, Phasenverschiebung, ...) - Abzugeben ist der Sourcecode als c-File, sowie die Excel Datei (.xlsx) # Allgemeine Vorgehensweise - Inhalt der Übung verstehen - Aufgabe in Teilaufgaben zerlegen + Struktur erstellen - Teilaufgaben einzeln lösen + TESTEN - Allgemein - Übersichtlichkeit -> Einrückung - Kommentare - sprechende Namen für Variablen und Funktionen verwenden + „coding style“ - Variablen … int dies_ist_eine_variable; - Funktionen … int diesIstEineFunktion(); - Achtung – in der Hauptschleife des Programms: - es gibt weniger output samples als input samples # Codeauszug (bitte verwenden) ```c #define NUM_SAMPLES 640 #define MAX_KERNELSIZE 64 // char beispiel_daten[4] = { 1, -4, 0, 18 }; char input_data[NUM_SAMPLES] = { #include \"sinus-6.txt\" }; // Inputdaten … sind zu filtern char output_data[NUM_SAMPLES]; // Outputdaten … //…hier wird das Ergebnis abgelegt char filter_kernel_size; // Filterbreite für den Filtervorgang // Schreiben in eine Datei // File schreiben vorbereiten FILE \\*input_file; // deklarieren des file-pointers „input_file“ input_file = fopen(\"Ausgabe.csv\",\"w\"); // öffnen der zu beschreibenden Datei // Schreiben in die Datei – zu verwenden wie „ printf “ fprintf(input_file ,\" Dieser Text wird %i mal in die Datei geschrieben\", 1); // nachdem alle Daten geschrieben wurden - Datei schließen fclose(input_file); ``` ",
    "url": "/ece-ip-uebungen/ip2/filter/",
    "relUrl": "/ip2/filter/"
  },"8": {
    "doc": "Übung 9 - Damenproblem",
    "title": "Übung 9 - Damenproblem",
    "content": "# Übung 9 - Damenproblem ## Themenbeschreibung Das Damenproblem ist eine schachmathematische Aufgabe. Es sollen jeweils acht Damen auf einem Schachbrett so aufgestellt werden, dass keine zwei Damen einander nach den Schachregeln schlagen können. Die Figurenfarbe wird dabei ignoriert, und es wird angenommen, dass jede Figur jede andere angreifen könnte. Oder anders ausgedrückt: Es sollen sich keine zwei Damen die gleiche Reihe, Linie oder Diagonale teilen. Im Mittelpunkt steht die Frage nach der Anzahl der möglichen Lösungen. Das Problem kann auf Schachbretter beliebiger Größe verallgemeinert werden. Dann gilt es, n nicht-dominierende Damen auf einem Brett von n x n Feldern zu positionieren. Für n = 8 hat das Damenproblem 92 verschiedene Lösungen. Betrachtet man Lösungen als gleich, die sich durch Spiegelung oder Drehung des Brettes auseinander ergeben, verbleiben noch zwölf Lösungen. Eine Lösung des Damnproblem mit Brettgröße 8x8 Die folgende Tabelle führt die Anzahl der eindeutigen Lösungen und die der gesamten Lösungen bis zur Brettgröße 26×26 auf: | **n** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 12 | 14 | 16 | 20 | 25 (Weltrekord - 2005) | 26 (Weltrekord - 2009) | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------ | ------- | ---------- | -------------- | ---------------------- | ---------------------- | eindeutig | 1 | 0 | 0 | 1 | 2 | 1 | 6 | 12 | 46 | 92 | 1.787 | 45.752 | 1.846.955 | 4.878.666.808 | 275.986.683.743.434 | 2.789.712.466.510.289 | insgesamt | 1 | 0 | 0 | 2 | 10 | 4 | 40 | 92 | 352 | 724 | 14.200 | 365.596 | 14.772.512 | 39.029.188.884 | 2.207.893.435.808.352 | 22.317.699.616.364.044 | # Programmieraufgabe Im ersten Schritt suchen wir gemeinsam eine intuitive Lösung und setzen diese in einem C-Programm um. Besonderes Augenmerk liegt diesmal in der Trennung zwischen Datenstruktur und Algorithmus. Subroutinen sollen sauber in eigene Funktionen gekapselt werden. Zum Beispiel soll das \"Setzen\" einer Dame oder das \"Löschen\" einer Dame in einer eigenen Funktion formuliert werden. Wir werden die \"Ordnung\" der Lösung besprechen und in einem zweiten Schritt einen zweiten, optimierten Lösungsweg besprechen und umsetzen. Ziel ist es, nur Teile des Programmes - nämlich die Datenstruktur - auszutauschen, um den zweiten Lösungsweg umzusetzen. Die Rechenzeit für eine Lösung wird mit dem zweiten Lösungsweg dramatisch niedriger sein. Während des Lösungsfindung soll das Programm - die Zeit zur Lösungsfindung messen - die Anzahl der aufgetretenen \"Konflikte\" zählen - die Anzahl der \"Lady removes\" zählen - **Optional** sollen statt nur einer Lösung ALLE möglichen Lösungen gefunden werden. Das Programm soll zumindest aus folgenden Funktionen bestehen: - setLady ... platziert eine Dame an der aktuellen Position - verifyConflict ... überprüft, ob an der aktuellen Position ein Konflikt (Bedrohung durch eine andere Dame) vorhanden ist - removeLady ... entfernt die zuletzt gesetzte Dame - printChessBoard ... gibt das n\\*n Schachbrett am Bildschirm aus Dieses Diagramm veranschaulicht die Rechenzeit zum finden EINER Lösung mit unserem Algorithmus mit dem intuitiven Algorithmus (orange) und der optimierten Datenstruktur (blau). Auf der Abszisse ist die Brettgröße aufgetragen. [Vorlagen](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/09-damenproblem/vorlage) ## Mögliche Ausgabe: ```bash ... Solution: 91 00x00000 0000x000 0x000000 00000000 00000x00 000x0000 000000x0 x0000000 Solution: 92 00x00000 00000x00 000x0000 0x000000 00000000 0000x000 000000x0 x0000000 92 Solutions found. Board Size: 8 counted collisions: 19736 collision overflows: 0 counted lady removes: 2057 lady remove overflows: 0 counted solutions: 92 Max countervalue: 4294967295 End Time: 0.220000 seconds ``` ",
    "url": "/ece-ip-uebungen/ip2/damenproblem/",
    "relUrl": "/ip2/damenproblem/"
  },"9": {
    "doc": "Übung 10 - Damenproblem Smart",
    "title": "Übung 10 - Damenproblem Smart",
    "content": "# Übung 10 - Damenproblem Smart Programmieren Sie das Damenproblem so um, dass es die besprochene Smart-Datenstruktur verwendet. Verwenden Sie eindimensionale Arrays für die Position der Damen (Spaltenvektor) und die Markierung der Strahlen (Zeilenvektor, Hauptdiagonalen- und Nebendiagonalenvektor) Der Algorithmus des Programms bleibt ident. Strukturieren Sie den Programmcode so, dass Sie nur ihre Subfunktionen für die Änderung der Datenstruktur anpassen müssen. zB: - Kollissionsprüfung - Dame setzen - Dame löschen Die Ordnung des Programmes sinkt wie besprochen von O($$n^4$$) auf O($$n^3$$). Die Ausführungszeit bei großen Brettgrößen sinkt dramatisch. Vergleichen Sie die Rechenzeiten beider Programme für EINE Lösung der Brettgrößen 31 oder 32. Teilen Sie mir die Ausführungszeiten mit. Das Programm soll wahlweise ALLE bzw. EINE Lösung finden können (Präprozessorschalter oder Benutzereingabe zur Laufzeit) Bei ALLEN Lösungen soll (zumindest) die Anzahl der Lösungen und bei EINER Lösung die Lösung selbst dargestellt werden. Des weiteren soll die Laufzeit gemessen und die Anzahl der \"Konflikte\" und \"lady removes\" gezählt und ausgegeben werden ",
    "url": "/ece-ip-uebungen/ip2/damenproblem-smart/",
    "relUrl": "/ip2/damenproblem-smart/"
  },"10": {
    "doc": "Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung)",
    "title": "Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung)",
    "content": "# Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung) ## Aufgabenstellung - Zu Schreiben ist ein Programm, welches Ausdrücke, die in Postfix-Notation gegeben sind, auswertet. - umzusetzten ist ein Algorithmus, welcher gemeinsam besprochen wird - Die Ausdrücke sind in Form eines konstanten Strings gegeben. zB `const char INPUT*STR[ ] = “3,13,4,5,*,+,4,6,+,*,+“;` - Die Zahlen können auch mehrstellig sein, sind aber auf positive Integerwerte beschränkt - Geben sie das berechnete Ergebnisses am Bildschirm aus - Der notwendige Stack und dessen Zugriffsroutinen sind in gesonderten Files (stack.c, stack.h) zu programmieren. - Auf den Stack wird mittels folgender Funktionen zugegriffen: `int push(int operand)` und `int pop(int *operand)` - Der return-Wert gibt dabei jeweils Information über den Erfolg der Operation (0...ok, -1...Fehler) - Der Stack ist mit Hilfe eines Arrays umzusetzten - Die Stackgröße ist mittels #define einzustellen: #define STACK_SIZE 5 - Folgende Operatoren sind umzusetzen: +, -, \\*, /, - Die Funktionen push, pop müssen eine Fehlerbehandlung für die Fälle (a) leerer Stapel und (b) voller Stapel haben - Ausgabe einer Fehlermeldung, sollte der Ausdruck nicht gültig sein [Postfix Basis](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/12-upn-auswertung/vorlage) ### Optionale Umsetzung - Einlesen des Inputstrings von der Tastatur - setzen Sie zusätzlich folgende Operatoren um: mod, -(Vorzeichen), ^, max, min wobei für max und min folgendes gilt: - der erste operand (=parameter), gibt die Anzahl der Werte, von denen das Maximum oder das Minimum bestimmt wird, an. d.h. die Funktionen max, min können beliebig viele Operanden haben. Die Operandenanzahl 1 ist ungültig. Hat die max oder min Funktion weniger Operanden als erwartet, so ist dafür eine Fehlerbehandlung zu implementieren. - lassen Sie auch Floatwerte zu ## Testdaten | INFIX | POSTFIX | ---------------------------------- | -------------------------------------------- | $$( 13 + 4 ) * 5$$ | 13 , 4 , + , 5 , \\* | $$13 + 4 * 5$$ | 13 , 4 , 5 , \\* , + | $$13 * 4 + 5$$ | 13 , 4 , \\* , 5 , + | $$( 13 * 4 + 5) * ( 2 – 1 ) + 3$$ | 13 , 4 , \\* , 5 , + , 2 , 1 , - , \\* , 3 , + | $$1 + ( 13 + 4 * 5 ) * 10$$ | 1 , 13 , 4 , 5 , \\* , + , 10 , \\* , + | $$((13 + 4) * 5 ) + (13 + 4 * 5)$$ | 13, 4, +, 5, \\*, 13, 4, 5, \\*, +, + | ",
    "url": "/ece-ip-uebungen/ip2/upn-auswertung/",
    "relUrl": "/ip2/upn-auswertung/"
  },"11": {
    "doc": "Übung 12 - Wiederholung Pointer und Strukturen",
    "title": "Übung 12 - Wiederholung Pointer und Strukturen",
    "content": "# Übung 12 - Widerholung Pointer und Strukturen Dies ist eine Zusammenstellung kleinerer Aufgaben zur Widerholung von Pointern und Strukturen. # Aufgabenstellung zur Wiederholung von Inhalten ## 1. Pointer Schreiben Sie folgendes kurzes Programm: 1. definieren Sie eine char Variable \"my_char\" und einen Pointer \"ptr_to_char\" Setzen Sie die char-Variable über den Pointer auf den Wert 33; 2. definieren Sie eine int Variable \"my_int\" und einen Pointer \"ptr_to_int\" Setzen Sie die int-Variable über den Pointer auf den Wert 1234; Geben Sie beide Variablen über die Variable selbst und über den zugehörigen Pointer am Bildschirm aus. ## 2. Strukturen Programmieren Sie ein kurzes Programm 1. Definieren Sie eine Struktur s_date mit folgenden Feldern: - `int my_day` - `int my_month` - `int my_year` - `char my_name[100]`; 2. definieren Sie eine struct-Variable my_s_date. Initialisieren Sie die Struktur auf Inhalte Ihrer Wahl . Geben Sie die Struktur am Bildschirm aus 3. Beschreiben Sie die Felder der struct-Variable my_s_date und geben Sie diese am Bildschirm aus 4. definieren Sie einen Pointer auf die obige Struktur und beschreiben Sie die Struktur über den Pointer mit anderen Werten Geben Sie die Struktur wieder am Bildschirm aus, aber diesmal über den Pointer ! ## 3. Malloc Programmieren Sie ein kurzes Programm 1. reservieren Sie mit malloc Platz für 60 short-Variablen übernehmen Sie den Speicher mit der Pointervariablen \"short_ptr\" 2. beschreiben Sie die ersten drei Elemente über den \"short_ptr\" 3. beschreiben Sie die nächsten drei Elemente über einen \"temp_ptr\", den Sie nach jedem Schreibzugriff inkrementieren temp_ptr++; 4. beschreiben Sie die nächsten drei Elemente über den \"short_ptr\" in der ARRAY-Schreibweise 5. geben Sie die ersten 12 Elemente über eine Scheife aus 6. geben Sie den reservierten Speicher wieder frei ",
    "url": "/ece-ip-uebungen/ip2/pointer-strukturen/",
    "relUrl": "/ip2/pointer-strukturen/"
  },"12": {
    "doc": "Übung 13 - Dynamischer Stack",
    "title": "Übung 13 - Dynamischer Stack",
    "content": "# Übung 13 - Dynamischer Stack ## Aufgabenstellung Ersetzen Sie den Stack der Übung 12 (Postfix Auswertung) durch einen dynamischen Stack. Anforderungen an den dynamischen Stack: - die Interfaces des Stacks (push und pop) bleiben ident, sodass der Tausch des Stacks keine Änderungen der beiden Übungen notwendig macht - Ein Stack Element soll mithilfe eines \"struct\" realisiert werden - Bei Hinzufügen eines Elements am Stack wird dynamisch ein Stack Element im Speicher reserviert (malloc) - Bei Entfernen eines Elements vom Stack wird das entfernte Stack Element im Speicher wieder frei gegeben (free) ",
    "url": "/ece-ip-uebungen/ip2/dynamischer-stack/",
    "relUrl": "/ip2/dynamischer-stack/"
  },"13": {
    "doc": "Übung 14 - Pointer und Strukturen",
    "title": "Übung 14 - Pointer und Strukturen",
    "content": "# Übung 14 - Pointer und Strukturen ## Pointer.c Erstellen Sie 1 File: pointer.c ### Pointer 1 - Definieren Sie eine Variable mit dem Typ unsigned short und weisen Sie diesem einen Wert (> 300) zu - Definieren Sie einen pointer mit dem Typ unsigned char\\* und zeigen Sie mit diesem auf dem unsigned short Wert (type cast notwendig!) - Geben Sie den Wert der unsigned short Variable mittels Pointer am Bildschirm aus. ### Pointer 2 - Definieren Sie einen pointer mit dem Typ unsigned short\\* und zeigen Sie mit diesem auf den unsigned short Wert - Geben Sie den Wert der unsigned short Variable mittels Pointer am Bildschirm aus. ### Pointer 3 - Definieren Sie eine Struktur Data, mittels typedef, die - ein unsigned char array mit Länge 4 ODER - 4 unsigned char Variablen beinhaltet (ACHTUNG: diverse IDE machen mit dieser Variante Probleme => siehe ANMERKUNG) - Definieren Sie eine Variable vom Typ Data und weisen Sie den Variablen Werte zu. - Zeigen Sie mit dem vorhin definierten unsigned char Pointer auf die Elemente dieser Struktur - Geben Sie die Werte der Struktur Variablen Data mithilfe des Pointers am Bildschirm aus - `*(ptr+1)` ODER - `ptr++`; `*ptr` ... - **ANMERKUNG**: LabWin CVI verwehrt den Zugriff auf vier einzelne unsigned char Elemente der Struktur über inkrementieren des Pointers ptr ### Pointer 4 - Definieren Sie einen Pointer auf die struct Data - Geben Sie die Werte der vorhin definierten Struktur Variablen Data mithilfe des Pointers am Bildschirm aus ## Strukturen.c Erstellen Sie 1 File: strukturen.c ### Strukturen 1 - Definieren Sie folgende Strukturen mittels typedef - `s_dataset` bestehend aus: - firstname (Text: 50 Zeichen) - surname (Text: 50 Zeichen) - date_of_birth (struct s_date) - `s_date` bestehend aus: - day (unsigned char) - month (unsigned char) - year (unsigned int) - Definieren Sie ein Array mit 4 Elementen von s_dataset und befüllen Sie dieses mit Daten - Definieren Sie einen Pointer vom Typ `s_dataset*` (z.B. `ptr1`) und geben Sie mithilfe des Pointers die Daten am Bildschirm aus - Defnieren Sie einen Pointer auf einen \"`s_dataset*` Pointer\" (Pointer auf Pointer !) (z.B. `pptr2`) mit dem Sie auf den vorherigen Pointer (`ptr1`) zeigen - Geben Sie die Daten des Arrays mithilfe der beiden Pointer aus. Dabei soll die Ausgabe am Bildschirm nur mit dem `pptr2` gemacht werden und der `ptr1` soll auf die einzelnen s_dataset's zeigen. ### Strukturen 2 - Verwenden Sie die typedef Strukturen `s_dataset` und `s_date` aus dem letzten Beispiel - Definieren Sie einen Pointer auf `s_dataset` - Allokieren Sie mithilfe von malloc den Speicher für `s_dataset` - Befüllen Sie die \"Variable\" mit Daten und geben Sie diese am Bildschirm aus - Geben Sie den Speicher mit free wieder frei ### Strukturen 3 - Erweitern Sie die Struktur s_dataset aus dem letzten Beispiel und geben Sie ihr den Namen s_dataset2_struct (verwenden Sie diesmal kein typedef). - fügen Sie zusätzlich einen Pointer auf s_dataset2 \"next_element\" in der Struktur ein - `s_dataset2_struct` bestehend aus: - firstname (Text: 50 Zeichen) - surname (Text: 50 Zeichen) - date_of_birth (`struct s_date`) - next_element (`struct s_dataset2_struct*`) - Definieren Sie einen Pointer auf `struct s_dataset2_struct` mit dem Namen `start_ptr` - Definieren Sie einen Pointer auf `struct s_dataset2_struct` mit dem Namen `act_ptr` - Allokieren nach und nach Speicher für ein struct s_dataset2_struct Element (insgesamt 3x) - Befüllen Sie dabei einige Daten mit Werten - Bilden Sie eine einfach verkettete Liste, indem `start_ptr` auf das erste Element zeigt und ein nachfolgendes Element an den `next_element` Pointer des vorigen Elements gehängt wird. - geben Sie alle verketteten Elemente auf den Bildschirm aus - verwenden Sie hierzu eine while-Schleife (Achtung: wie erkennen Sie das Ende der verketteten Liste?) - verwenden Sie act_ptr, um auf die einzelnen Elemente zuzugreifen - Geben Sie den Speicher aller Elemente mit free wieder frei ",
    "url": "/ece-ip-uebungen/ip2/pointer-strukturen-2/",
    "relUrl": "/ip2/pointer-strukturen-2/"
  },"14": {
    "doc": "Übung 15 - Sortieralgorithmen",
    "title": "Übung 15 - Sortieralgorithmen",
    "content": "# Übung 15 - Sortieralgorithmen ## Aufgabenstellung Es soll mittels Insert Sort Algorithmus ein Array von integer Zahlen sortiert werden. Anforderungen an den Sortieralgorithmus - Erstellen Sie ein main.c file - aus der main.c können verschiedene Sortieralgorithmen aufgerufen werden, von denen wir vorerst einen programmieren - Das zu sortierende Zahlenarray ist wie folgt zu definieren: - `int sort_array[] = {92,4,6,7,252,4,83,5,49,10,134,156,7,29};` - Die Größe des Arrays soll per sizeof Funktion festgestellt werden - es ist eine Funktion `sort(...)` zu erstellen, der folgende Parameter mitgegeben werden - ein per enum definierter Wert, welcher Sortieralgorithmus angewendet werden soll - Pointer auf das zu sortierende Array - Länge des Arrays - main ruft die Sortieralgorithmen über `sort(...)` auf - `sort(...)` misst die Laufzeit des aufgerufenen Sortieralgorithmus und gibt diese aus - Erstellen sie eine insertsort.c und insertsort.h Datei - Die insertsort.c Datei enthält die Funktion insertSort, welcher das zu sortierende Array übergeben wird. Die Funktion sortiert das Array nach dem Insertionsort Algorithmus und gibt die Zahlen sortiert aus ## Dynamisch erzeugtes Array mit Zufallszahlen Wer möchte, kann sich über den unten verlinkten code dynamisch ein array mit Zufallszahlen erzeugen lassen. Die Arraygröße kann mit einem DEFINE eingestellt werden. ```c #define ARRAY_SIZE 1000000 ``` Das dynamisch erzeugte Array heißt `number_array` und ist vom Typ `unsigned long` [Vorlage](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/15-sortieralgorithmen/vorlage) ## Erweiterung - zusätzlicher Sortieralgorithmus Erweitern Sie Ihre Software um einen zusätzlichen Sortieralgorithmus. Der neue Algorithmus (eigenes .c und .h file) soll in das bestehende Programm eingebunden werden. Die Übergabe der Parameter, sowie die Ausgabe des Ergebnisses und eine eventuelle Zeitmessung ist wie in obiger Übung (Main - Modul) beschrieben umzusetzen. Alle Studierenden, die in der Vorlesung einen Sortieralgorithmus präsentiert haben, setzen bitte diesen Algorithmus um. Jedes Gruppenmitglied schreibt einen eigenen Code. Bitte unterschiedliche Implementierungen umsetzen (rekursiv/iterativ) Alle anderen Studierenden programmieren den Algorithmus, den wir gemeinsam vereinbart haben (siehe Einteilung). ### Im WIKI zur Verfügung stellen Zusätzlich zur Übungsabgabe stellen Sie bitte Ihren Sortieralgorithmus für alle im \"WIKI-Sortieralgorithmen\" bereit. Legen Sie Ihr zip-File, bestehend aus .c und .h File (ohne main), unter der jeweiligen Überschrift ab. Achtung: Filenamen und Funktionsaufruf sollen eindeutig sein (inkludieren Sie zB Ihren Nachnamen) ## Erweiterung - Testen von Funktionen Erweitern Sie Ihr Programm folgend: - Zu Beginn wählen Sie das zu sortierende Array aus. Es soll möglich sein, aus folgenden Optionen zu wählen: - vordefiniertes zu sortierendes Array - zufällig generiertes Zahlenarray mit/ohne Duplikaten - Eingabemöglichkeit Anzahl der Elemente - Anlegen einer Kopie des Arrays - Sortieren Sie das Array in in ein weiteres \"sorted\"-Array (verwenden Sie dafür den Sortieralgorithmus Ihrer Wahl) - Binden Sie mindestens 10 weitere Sortieralgorithmen in Ihr Programm ein - plus zusätzlich einen Standard-Sortieralgorithmus (zB aus stdlib.h ) - Führen Sie ALLE Sortieralgorithmen hintereinander aus - Referenz-Array kopieren - Zeitmessung starten - Array sortieren - Zeitmessung stoppen - Array mit dem \"sorted\"-Array vergleichen - Zusammenfassung anzeigen (PASS / FAIL, verstrichene Zeit) - Anzeige evtl in Farbe ### Anmerkung: - verwenden Sie für die verschiedenen Sortieralgorithmen ein ENUM in einer switch-case Struktur - die einzelnen Sortieralgorithmen können innerhalb einer Schleife, die NUM_SORTING_ALGORITHMS mal durchlaufen wird gestartet werden ",
    "url": "/ece-ip-uebungen/ip2/sortieralgorithmen/",
    "relUrl": "/ip2/sortieralgorithmen/"
  },"15": {
    "doc": "Übung 16 - Binärbaum + AVL Baum",
    "title": "Übung 16 - Binärbaum + AVL Baum",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/binaer-avl-baum/",
    "relUrl": "/ip2/binaer-avl-baum/"
  },"16": {
    "doc": "Übung 17 - Sequentielle, binäre und Interpolationssuche",
    "title": "Übung 17 - Sequentielle, binäre und Interpolationssuche",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/suchalgorithmen/",
    "relUrl": "/ip2/suchalgorithmen/"
  },"17": {
    "doc": "Übungen für IP2",
    "title": "Übungen für IP2",
    "content": "# Übungen für IP2 ",
    "url": "/ece-ip-uebungen/ip2",
    "relUrl": "/ip2"
  },"18": {
    "doc": "Übungen für IP1",
    "title": "Übungen für IP1",
    "content": "# Übungen für IP1 ",
    "url": "/ece-ip-uebungen/ip1",
    "relUrl": "/ip1"
  }
}
