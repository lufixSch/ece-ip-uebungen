{"0": {
    "doc": "Übung 1 - Sonderzeichen",
    "title": "Übung 1 - Sonderzeichen",
    "content": "# Übung 1 - Sonderzeichen ## Aufgabenstellung Schreiben Sie ein C-Programm, das folgenden oder ähnlichen Inhalte auf stdio ausgibt : - Einen Text mit Zahl, die dezimal, hexadezimal und oktal ausgegeben wird (zB 232) - Probieren Sie verschiedene Formatelemente aus (zB %7.2f) - Bauen Sie verschiedene Escape Sequenzen ein (zB new line, tab, alert, ...) - geben Sie Umlaute und \"ß\" aus - Stellen Sie ein ASCII Bild dar (‘%‘ , ' \" ' , und ‘\\‘ sollen enthalten sein) - [Text to ASCII Art Generator](http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something) ",
    "url": "/ece-ip-uebungen/ip1/sonderzeichen/",
    "relUrl": "/ip1/sonderzeichen/"
  },"1": {
    "doc": "Übung 2 - Datum und Uhrzeit",
    "title": "Übung 2 - Datum und Uhrzeit",
    "content": "# Übung 2 - Datum und Uhrzeit ## Aufgabenstellung: Schreiben Sie ein Programm, das Datum und Uhrzeit sekündlich als Text am Bildschirm darstellt. - Jedes Feld (Sekunde, Minute, …) ist in einer eigenen Variable abgelegt - (welchen Datentyp verwenden Sie?) - sekündlich wird die Variable „Sekunde“ erneuert und Datum/Zeit neu angezeigt. - Die Zeitverzögerung ist manuell mittels Schleife umzusetzen - Nach jedem Sekunden-Inkrement sind die Überläufe der weiteren Variablen (Minute, Stunde, … ) zu errechnen - zB.: - 14:23:59 => 14:24:00 - 2014-03-31 23:59:59 => 2014-04-01 00:00:00 - implementieren Sie unterschiedliche Anzahl an Tagen je Monat - berücksichtigung von Schaltjahren (beachte die Regel für jedes 4., 100. und 400. Jahr) - **WICHTIG**: testen Sie alle Überlaufmöglichkeiten! - Achten Sie auf die Einhaltung unseres Coding Styles ### Vorgaben - Sekunde: 0..59 - Minute: 0..59 - Stunde: 0..23 - Tag: 1..31 - Monat: 1..12 - Jahr: vierstellig ",
    "url": "/ece-ip-uebungen/ip1/datum-uhrzeit/",
    "relUrl": "/ip1/datum-uhrzeit/"
  },"2": {
    "doc": "Übung 3 - Funktionen und Operatoren - Binäre Darstellung",
    "title": "Übung 3 - Funktionen und Operatoren - Binäre Darstellung",
    "content": "# Übung 3 - Funktionen und Operatoren - Binäre Darstellung ## Übungsinhalt - Funktionen - Interpretation von Zahlen (dez, hex, binär) - Binäre und logische Operatoren - Coding Style ## Aufgabenstellung Schreiben Sie ein Programm, das binäre Operationen ausführt und das Ergebnis binär am Bildschirm darstellt. Achten Sie auf die Einhaltung unseres Coding Styles. Dazu werden zwei Variablen (`a`, `b`) verwendet, die mit folgenden Werten vorbelegt sind: ```c unsigned char a = 0x1C; //0001 1100 unsigned char b = 0x55; //0101 0101 ``` Folgende sieben Operationen sind auszuführen und am Bildschirm darzustellen: - a >> 1 (right shift) - a > 1: 00011100 >> 1 = 00001110 ``` **ODER** ```c a | b: 00011100 | 01010101 = ``` **ODER** ```c b % a: 85 % 28 = entspricht 01010101 % 00011100 = ``` Stellen Sie die Variablen vor und nach der binären Operation binär dar. Verwenden Sie für die Ausgabe in binär Darstellung folgenden Funktionsrumpf und erweitern Sie diesen: ```c // Zahl binär auf den Bildschirm ausgeben void charBinaerAusgeben(unsigned char zahl) { //benützen Sie für diese Funktion binäre Operatoren // > & | ^ ~ for () { if () printf(\"1\"); else printf(\"0\"); } } ``` ",
    "url": "/ece-ip-uebungen/ip1/binaere-darstellung/",
    "relUrl": "/ip1/binaere-darstellung/"
  },"3": {
    "doc": "Übung 4 - Mittelwertbildung",
    "title": "Übung 4 - Mittelwertbildung",
    "content": "# Übung 4 - Mittelwertbildung ## Übungsinhalte - Arrays - switch Anweisung - Wiederholung bisheriger Themen ## Aufgabenstellung Schreiben Sie ein Programm, das maximal 10 Zahlen von der Tastatur einliest, in einem Array ablegt und am Ende den Mittelwert der Zahlen berechnet Augenmerk liegt bei diesem Programm auf: - Robustheit: Das Programm soll jegliche Eingabe akzeptieren, ohne in einen undefinierten Zustand zu kommen wohl überlegte Plausibilitätsprüfungen! - Benutzerführung: Der Benutzer soll durch das Programm geführt werden und sich dabei auskennen Fehlermeldungen bei Fehleingabe! z.B. auch wie viele Zahlen bereits eingegeben - wurden - Programmstruktur: klare, leicht lesbare Programmstruktur - Kommentare an entscheidenden Stellen ## Detailanforderungen - Beschreibung am Beginn, was vom Benutzer erwartet wird und was das Programm tun wird - Vom Benutzer eingegebener Text wird ausgewertet. Wenn es sich um eine Zahl handelt, muss der „Zahlentext“ in eine Zahl umgewandelt und anschließend im array abgelegt werden - Anm: die Funktion atoi() oder ähnlich ist nicht erlaubt - Eingabe des Benutzers: - Es wird ein Befehl ODER eine Zahl eingegeben. - Die Eingabe wird mit abgeschlossen. - Bei den Befehlen sollen Klein- und Großbuchstaben akzeptiert werden. - ‚X‘ oder ‚Z‘ … Beenden des Programms - ‚L‘ … löschen aller bisherigen eingegebenen Zahlen - ‚A‘ … Ausgabe des Mittelwerts zum aktuellen Zeitpunkt (auch zwischendurch) - Zahlen: - Ziffern 0..9 erlaubt, keine anderen Zeichen (+,-, r,…) - Keine negativen Zahlen - Wertebereich: 0 bis höchstmögliche 4-byte Zahl - Geeignete Meldungen bei Fehleingabe überlegen … nicht „lästig“ und kurz und prägnant! - Achten Sie auf die Einhaltung unseres Coding Styles ## Vorgaben - Für die Eingabe: - (Anmerkung: `scanf` mit Formatbezeichner `%s`: Der eingegebene Text wird im character-Array automatisch mit dem Abschlusszeichen '\\0' abgeschlossen) ```c char benutzer_eingabe[100]; scanf(\"%s\", benutzer_eingabe); ``` - Datenstruktur / Array: ```c char zahlen_zaehler; unsigned int zahlen_puffer[10]; ``` **es gilt immer** - Aufgabenstellung verstehen - Struktur überlegen - Aufgabenstellung in Einzelaufgaben zerlegen - Einzelaufgaben im Detail planen - Dann erst Schritt für Schritt umsetzen ",
    "url": "/ece-ip-uebungen/ip1/mittelwertbildung/",
    "relUrl": "/ip1/mittelwertbildung/"
  },"4": {
    "doc": "Übung 5 - Arduino Übung - Blink",
    "title": "Übung 5 - Arduino Übung - Blink",
    "content": "# Übung 5 - Arduino Übung - Blink Als Basis für diese Übung dient das Arduino Basics-Beispielprogramm \"blink\" ## Aufgabenstellung Geben Sie EIN Sourcefile (\\*.ino) ab, in dem alle Übungsteile enthalten sind (Teile kennzeichnen und auskommentieren) ### Übung 1: Am Arduino Board befindet sich am Port 13 eine LED, diese LED soll mit einer Frequenz von 5 Hz blinken. Verwenden Sie für die Übung 1 bis 4 zum Blinken die Funktionen digitalWrite und delay. ### Übung 2: erhöhen Sie die Blinkfrequenz so lange, bis Sie kein Blinken mehr erkennen können. Bestimmen Sie die Blinkfrequenz durch Errechnen aus ON-Zeit und OFF-Zeit der LED. Machen Sie sich Gedanken, welchen Zusammenhang dies mit der Bildschirmwiederholfrequenz hat. ### Übung 3: Bleiben Sie auf einer Blinkfrequenz, die vom Auge nicht mehr als Blinken erkannt wird und verstellen Sie die ON-Zeit der LED zwischen Minimum und Maximum. Anmerkung: Wenn die Frequenz gleich bleiben soll, muss sich bei Erhöhung der ON-Zeit die OFF-Zeit verringern. (ON-Zeit + OFF-Zeit = konstant) Sie können so die Helligkeit der LED verstellen. ### Übung 4: Die Helligkeit der LED soll über einen Potentiometer eingestellt werden: Lesen Sie über den analogen Input A0 (`analogRead()`) einen analogen Wert eines Potentiometers ein. Der analoge Wert soll durch Verstellen des Potentiometers zwischen 0V und 5V veränderbar sein. Verstellen Sie in Abhängigkeit des eingelesenen analogen Wertes die Helligkeit der LED durch verstellen der ON-Zeit und der OFF-Zeit der LED. Berechnen Sie die Zeiten manuell (ohne die Funktion `map()`) Zusätzlich zur LED an PIN 13 schließen Sie eine externe LED an einem PWM fähigen Digitalpin an und steuern auch diese gleich wie die LED an PIN 13 an. #### Anforderungen: - LED leutet nicht bei Einlesen des minimalen analogen Wertes - LED leutet mit 100% Helligkeit bei Einlesen des maximalen analogen Wertes - Linearer Zusammenhang zwischen Helligkeit und dem analogen Wert: - verwenden Sie für die Umrechnung die Geradengleichung ($$y = k\\cdotx + d$$) ### Übung 5: Verändern Sie Übung 4 , indem Sie digitalWrite und delay gegen analogWrite (Hardware PWM) austauschen. Beachten Sie, dass analogWrite NICHT für die builtin LED an PIN 13 funktioniert, sondern lediglich an bestimmten Digitalpins. Lesen Sie nach warum. Fügen Sie am Ende der loop ein zusätzliches delay von 2 Sekunden ein, um zu beobachten, dass die LED auch während dieses delays angesteuert wird. Versuchen Sie das selbe mit Übung 4 und überlegen Sie, warum es in dieser Variante nicht funktioniert. ### Übung 6: Verwenden Sie für die Umrechnung der Helleigkeit statt der Geradengleichung die Funktion `map()`. Schreiben Sie die den Helligkeitswert der LED in Prozent in regelmäßigen Abständen in den Serial Monitor (`Serial.print()`) Anstatt die LED manuell ein und auszuschalten, können Sie auch die Funktion `analogWrite(...)` verwenden. Überlegen Sie, welchen Einfluss nun das delay in \"`loop()`\" auf das Verhalten der Applikation hat. ",
    "url": "/ece-ip-uebungen/ip1/blink/",
    "relUrl": "/ip1/blink/"
  },"5": {
    "doc": "Übung 6 - Arduino Übung - Parksensor",
    "title": "Übung 6 - Arduino Übung - Parksensor",
    "content": "# Übung 6 - Arduino Übung - Parksensor ## Aufgabenstellung Es ist ein Arduino-Programm zu realisieren, das folgende Elemente enthält: - Statemachine - Taster einlesen (Zustands- und Flankenerkennung) - LED ansteuern (AUS, EIN, blinken) - Ultraschallsensor einlesen (verwendete Type: HC-SR04) - Schreiben auf die serielle Schnittstelle - Die Statemachine ist analog zum unten abgebildeten Zustandsdiagramm zu realisieren. \"1\" repräsentiert den Startstate. Über die serielle Schnittstelle ist das Verhalten der Applikation auszugeben. - (zB Zustandswechsel der Statemachine, erkannte Tastendruckereignisse, aktueller Entfernungswerte des Ultraschallsensors,...) - Es ist besonders auf die Einhaltung unseres Coding-Styles zu achten. optional können Sie folgende Punkte realsieren: - geben Sie wie bei einem Parksensor den Abstand des erkannten Objekts akustisch aus. - Verwenden Sie hierzu einen kleinen Lautsprecher oder Piezo Beeper. - Je näher das Objekt kommt, desto schneller piept das akustische Signal. - Bei Unterschreitung des Mindestabstandes ertönt ein permanentes akustisches Signal. - Das akustische Signal könnte in Abhängigkeit des Abstands neben der Piep-frequenz auch die Tonhöhe verändern ## Hilfsmittel Diagramm zum Aufbau der Statemachine [Datenblatt des Ultraschallsensors](https://cdn.sparkfun.com/datasheets/Sensors/Proximity/HCSR04.pdf) ",
    "url": "/ece-ip-uebungen/ip1/parksensor/",
    "relUrl": "/ip1/parksensor/"
  },"6": {
    "doc": "Übung 7 - Arduino Übung - Rollosteuerung",
    "title": "Übung 7 - Arduino Übung - Rollosteuerung",
    "content": "# Übung 7 - Arduino Übung - Rollosteuerung Es soll eine Rollosteuerung an Hand einer Statemachine entwickelt werden. Die Befehle \"Rollo AUF\" und \"Rollo AB\" sollen mithilfe eines Tasters (Digital-Eingang), sowie der Funkfernbedienung umgesetzt werden. Die Position und Aktivität der Rollo wird mittels zweier LED (ROT... Position oben, GRÜN ... Position unten) signalisiert. (siehe Bild) Die gesamte Laufzeit der Rollo beträgt 10 Sekunden. Das Programm soll sich die Position der Rollo merken (Zeitzähler) Die Statemachine steuert zusätzlich einen Servomotor an, der sich zwischen linker Endposition (ROLLO OBEN) und rechter Endposition (ROLLO UNTEN) bewegt. Ein LDR liefert ein zusätzliches Eingangssignal, der bei übermäßiger Lichteinstrahlung die Rollo absenken lässt wenn es dunkel wird, die Rollo absenkt und bei Sonnenaufgang die Rollo wieder öffnet ## Eingänge: - Taster AB - Taster AUF - Infrarot Fernbedienung (Auf, Ab Tasten können selbst gewählt werden) - LDR (Dämmerung) ## Ausgänge - LED für Rollo öffnet/oben - LED für Rollo schließt/unten - Servo Motor ## Statemachine: Diagramm zum Aufbau der Statemachine Weitere Informationen zum Aufbau des Programms ",
    "url": "/ece-ip-uebungen/ip1/rollosteuerung/",
    "relUrl": "/ip1/rollosteuerung/"
  },"7": {
    "doc": "Übung 8 - Filter",
    "title": "Übung 8 - Filter",
    "content": "# Übung 8 - Filter ## Übungsinhalte - Arrays - Kontrollstrukturen - Tastatureingabe - lesen aus einer Datei und schreiben in eine Datei - Coding Style ## Begriffe in diesem Zusammenhang Abtasttheorem nach Shannon, Filterkern, Faltung, Glättung ... ## Aufgabenstellung Schreiben Sie ein Programm, das Daten aus einem File einliest und anschließend filtert und wieder ausgibt. Bei den Daten handelt es sich um 640 char-Zahlenwerte, die einen \"verrauschten\" sinusförmigen Verlauf darstellen. (siehe „sinus-6.txt“) Nach Einlesen der Daten soll der Benutzer aufgefordert werden, eine Filterbreite einzugeben. Die Filterbreite repräsentiert die Anzahl der Werte, über die jeweils gleitend der Mittelwert gebildet wird. Gültige Werte für die Filterbreite sind von 1 bis 64. Analysieren Sie die Auswirkung verschiedener Filterbreiten, in dem Sie die gefilterten Daten in Excel visualisieren. Dokumentieren Sie ihre Erkenntnisse und begründen Sie. [zu filternde Rohdaten](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/08-filter) ## Detailanforderungen - Das Programm soll bei Start eine Beschreibung ausgeben, was vom Benutzer erwartet wird und was das Programm tun wird - Vom Benutzer eingegebener Text wird ausgewertet. Wenn es sich um eine Zahl handelt, muss der „Zahlentext“ in eine Zahl umgewandelt werden. Die eingegebene Zahl stellt die zu verwendende Filterbreite dar. Prüfen Sie den eingegebenen Wert auf Plausibilität (gültige Werte: 1 bis 64) - Filtern Sie die Daten durch Faltung mit dem besprochenen Filterkern - Schreiben Sie die gefilterten Daten in eine Datei, die Sie in Excel importieren/öffnen können (.csv) - vergleichen Sie das Ergebnis verschiedener Filterbreiten und stellen Sie diese grafisch in einem Excel Dokument dar - Beschreiben Sie Ihre Beobachtungen im Excel Dokument - welcher Filter liefert einen sauberen Sinusverlauf in den gefilterten Daten - Was beobachten Sie in den gefilterten Daten mit steigender Filterbreite und warum? (Amplitude, Phasenverschiebung, ...) - Abzugeben ist der Sourcecode als c-File, sowie die Excel Datei (.xlsx) # Allgemeine Vorgehensweise - Inhalt der Übung verstehen - Aufgabe in Teilaufgaben zerlegen + Struktur erstellen - Teilaufgaben einzeln lösen + TESTEN - Allgemein - Übersichtlichkeit -> Einrückung - Kommentare - sprechende Namen für Variablen und Funktionen verwenden + „coding style“ - Variablen … int dies_ist_eine_variable; - Funktionen … int diesIstEineFunktion(); - Achtung – in der Hauptschleife des Programms: - es gibt weniger output samples als input samples # Codeauszug (bitte verwenden) ```c #define NUM_SAMPLES 640 #define MAX_KERNELSIZE 64 // char beispiel_daten[4] = { 1, -4, 0, 18 }; char input_data[NUM_SAMPLES] = { #include \"sinus-6.txt\" }; // Inputdaten … sind zu filtern char output_data[NUM_SAMPLES]; // Outputdaten … //…hier wird das Ergebnis abgelegt char filter_kernel_size; // Filterbreite für den Filtervorgang // Schreiben in eine Datei // File schreiben vorbereiten FILE \\*input_file; // deklarieren des file-pointers „input_file“ input_file = fopen(\"Ausgabe.csv\",\"w\"); // öffnen der zu beschreibenden Datei // Schreiben in die Datei – zu verwenden wie „ printf “ fprintf(input_file ,\" Dieser Text wird %i mal in die Datei geschrieben\", 1); // nachdem alle Daten geschrieben wurden - Datei schließen fclose(input_file); ``` ",
    "url": "/ece-ip-uebungen/ip2/filter/",
    "relUrl": "/ip2/filter/"
  },"8": {
    "doc": "Übung 9 - Damenproblem",
    "title": "Übung 9 - Damenproblem",
    "content": "# Übung 9 - Damenproblem ## Themenbeschreibung Das Damenproblem ist eine schachmathematische Aufgabe. Es sollen jeweils acht Damen auf einem Schachbrett so aufgestellt werden, dass keine zwei Damen einander nach den Schachregeln schlagen können. Die Figurenfarbe wird dabei ignoriert, und es wird angenommen, dass jede Figur jede andere angreifen könnte. Oder anders ausgedrückt: Es sollen sich keine zwei Damen die gleiche Reihe, Linie oder Diagonale teilen. Im Mittelpunkt steht die Frage nach der Anzahl der möglichen Lösungen. Das Problem kann auf Schachbretter beliebiger Größe verallgemeinert werden. Dann gilt es, n nicht-dominierende Damen auf einem Brett von n x n Feldern zu positionieren. Für n = 8 hat das Damenproblem 92 verschiedene Lösungen. Betrachtet man Lösungen als gleich, die sich durch Spiegelung oder Drehung des Brettes auseinander ergeben, verbleiben noch zwölf Lösungen. Eine Lösung des Damnproblem mit Brettgröße 8x8 Die folgende Tabelle führt die Anzahl der eindeutigen Lösungen und die der gesamten Lösungen bis zur Brettgröße 26×26 auf: | **n** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 12 | 14 | 16 | 20 | 25 (Weltrekord - 2005) | 26 (Weltrekord - 2009) | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------ | ------- | ---------- | -------------- | ---------------------- | ---------------------- | eindeutig | 1 | 0 | 0 | 1 | 2 | 1 | 6 | 12 | 46 | 92 | 1.787 | 45.752 | 1.846.955 | 4.878.666.808 | 275.986.683.743.434 | 2.789.712.466.510.289 | insgesamt | 1 | 0 | 0 | 2 | 10 | 4 | 40 | 92 | 352 | 724 | 14.200 | 365.596 | 14.772.512 | 39.029.188.884 | 2.207.893.435.808.352 | 22.317.699.616.364.044 | # Programmieraufgabe Im ersten Schritt suchen wir gemeinsam eine intuitive Lösung und setzen diese in einem C-Programm um. Besonderes Augenmerk liegt diesmal in der Trennung zwischen Datenstruktur und Algorithmus. Subroutinen sollen sauber in eigene Funktionen gekapselt werden. Zum Beispiel soll das \"Setzen\" einer Dame oder das \"Löschen\" einer Dame in einer eigenen Funktion formuliert werden. Wir werden die \"Ordnung\" der Lösung besprechen und in einem zweiten Schritt einen zweiten, optimierten Lösungsweg besprechen und umsetzen. Ziel ist es, nur Teile des Programmes - nämlich die Datenstruktur - auszutauschen, um den zweiten Lösungsweg umzusetzen. Die Rechenzeit für eine Lösung wird mit dem zweiten Lösungsweg dramatisch niedriger sein. Während des Lösungsfindung soll das Programm - die Zeit zur Lösungsfindung messen - die Anzahl der aufgetretenen \"Konflikte\" zählen - die Anzahl der \"Lady removes\" zählen - **Optional** sollen statt nur einer Lösung ALLE möglichen Lösungen gefunden werden. Das Programm soll zumindest aus folgenden Funktionen bestehen: - setLady ... platziert eine Dame an der aktuellen Position - verifyConflict ... überprüft, ob an der aktuellen Position ein Konflikt (Bedrohung durch eine andere Dame) vorhanden ist - removeLady ... entfernt die zuletzt gesetzte Dame - printChessBoard ... gibt das n\\*n Schachbrett am Bildschirm aus Dieses Diagramm veranschaulicht die Rechenzeit zum finden EINER Lösung mit unserem Algorithmus mit dem intuitiven Algorithmus (orange) und der optimierten Datenstruktur (blau). Auf der Abszisse ist die Brettgröße aufgetragen. [Vorlagen](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/09-damenproblem/vorlage) ## Mögliche Ausgabe: ```bash ... Solution: 91 00x00000 0000x000 0x000000 00000000 00000x00 000x0000 000000x0 x0000000 Solution: 92 00x00000 00000x00 000x0000 0x000000 00000000 0000x000 000000x0 x0000000 92 Solutions found. Board Size: 8 counted collisions: 19736 collision overflows: 0 counted lady removes: 2057 lady remove overflows: 0 counted solutions: 92 Max countervalue: 4294967295 End Time: 0.220000 seconds ``` ",
    "url": "/ece-ip-uebungen/ip2/damenproblem/",
    "relUrl": "/ip2/damenproblem/"
  },"9": {
    "doc": "Übung 10 - Damenproblem Smart",
    "title": "Übung 10 - Damenproblem Smart",
    "content": "# Übung 10 - Damenproblem Smart Programmieren Sie das Damenproblem so um, dass es die besprochene Smart-Datenstruktur verwendet. Verwenden Sie eindimensionale Arrays für die Position der Damen (Spaltenvektor) und die Markierung der Strahlen (Zeilenvektor, Hauptdiagonalen- und Nebendiagonalenvektor) Der Algorithmus des Programms bleibt ident. Strukturieren Sie den Programmcode so, dass Sie nur ihre Subfunktionen für die Änderung der Datenstruktur anpassen müssen. zB: - Kollissionsprüfung - Dame setzen - Dame löschen Die Ordnung des Programmes sinkt wie besprochen von O($$n^4$$) auf O($$n^3$$). Die Ausführungszeit bei großen Brettgrößen sinkt dramatisch. Vergleichen Sie die Rechenzeiten beider Programme für EINE Lösung der Brettgrößen 31 oder 32. Teilen Sie mir die Ausführungszeiten mit. Das Programm soll wahlweise ALLE bzw. EINE Lösung finden können (Präprozessorschalter oder Benutzereingabe zur Laufzeit) Bei ALLEN Lösungen soll (zumindest) die Anzahl der Lösungen und bei EINER Lösung die Lösung selbst dargestellt werden. Des weiteren soll die Laufzeit gemessen und die Anzahl der \"Konflikte\" und \"lady removes\" gezählt und ausgegeben werden ",
    "url": "/ece-ip-uebungen/ip2/damenproblem-smart/",
    "relUrl": "/ip2/damenproblem-smart/"
  },"10": {
    "doc": "Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung)",
    "title": "Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung)",
    "content": "# Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung) ## Aufgabenstellung - Zu Schreiben ist ein Programm, welches Ausdrücke, die in Postfix-Notation gegeben sind, auswertet. - umzusetzten ist ein Algorithmus, welcher gemeinsam besprochen wird - Die Ausdrücke sind in Form eines konstanten Strings gegeben. zB `const char INPUT*STR[ ] = “3,13,4,5,*,+,4,6,+,*,+“;` - Die Zahlen können auch mehrstellig sein, sind aber auf positive Integerwerte beschränkt - Geben sie das berechnete Ergebnisses am Bildschirm aus - Der notwendige Stack und dessen Zugriffsroutinen sind in gesonderten Files (stack.c, stack.h) zu programmieren. - Auf den Stack wird mittels folgender Funktionen zugegriffen: `int push(int operand)` und `int pop(int *operand)` - Der return-Wert gibt dabei jeweils Information über den Erfolg der Operation (0...ok, -1...Fehler) - Der Stack ist mit Hilfe eines Arrays umzusetzten - Die Stackgröße ist mittels #define einzustellen: #define STACK_SIZE 5 - Folgende Operatoren sind umzusetzen: +, -, \\*, /, - Die Funktionen push, pop müssen eine Fehlerbehandlung für die Fälle (a) leerer Stapel und (b) voller Stapel haben - Ausgabe einer Fehlermeldung, sollte der Ausdruck nicht gültig sein [Postfix Basis](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/11-upn-auswertung/vorlage) ### Optionale Umsetzung - Einlesen des Inputstrings von der Tastatur - setzen Sie zusätzlich folgende Operatoren um: mod, -(Vorzeichen), ^, max, min wobei für max und min folgendes gilt: - der erste operand (=parameter), gibt die Anzahl der Werte, von denen das Maximum oder das Minimum bestimmt wird, an. d.h. die Funktionen max, min können beliebig viele Operanden haben. Die Operandenanzahl 1 ist ungültig. Hat die max oder min Funktion weniger Operanden als erwartet, so ist dafür eine Fehlerbehandlung zu implementieren. - lassen Sie auch Floatwerte zu ## Testdaten | INFIX | POSTFIX | ---------------------------------- | -------------------------------------------- | $$( 13 + 4 ) * 5$$ | 13 , 4 , + , 5 , \\* | $$13 + 4 * 5$$ | 13 , 4 , 5 , \\* , + | $$13 * 4 + 5$$ | 13 , 4 , \\* , 5 , + | $$( 13 * 4 + 5) * ( 2 – 1 ) + 3$$ | 13 , 4 , \\* , 5 , + , 2 , 1 , - , \\* , 3 , + | $$1 + ( 13 + 4 * 5 ) * 10$$ | 1 , 13 , 4 , 5 , \\* , + , 10 , \\* , + | $$((13 + 4) * 5 ) + (13 + 4 * 5)$$ | 13, 4, +, 5, \\*, 13, 4, 5, \\*, +, + | ",
    "url": "/ece-ip-uebungen/ip2/upn-auswertung/",
    "relUrl": "/ip2/upn-auswertung/"
  },"11": {
    "doc": "Übung 12 - Wiederholung Pointer und Strukturen",
    "title": "Übung 12 - Wiederholung Pointer und Strukturen",
    "content": "# Übung 12 - Widerholung Pointer und Strukturen Dies ist eine Zusammenstellung kleinerer Aufgaben zur Widerholung von Pointern und Strukturen. # Aufgabenstellung zur Wiederholung von Inhalten ## 1. Pointer Schreiben Sie folgendes kurzes Programm: 1. definieren Sie eine char Variable \"my_char\" und einen Pointer \"ptr_to_char\" Setzen Sie die char-Variable über den Pointer auf den Wert 33; 2. definieren Sie eine int Variable \"my_int\" und einen Pointer \"ptr_to_int\" Setzen Sie die int-Variable über den Pointer auf den Wert 1234; Geben Sie beide Variablen über die Variable selbst und über den zugehörigen Pointer am Bildschirm aus. ## 2. Strukturen Programmieren Sie ein kurzes Programm 1. Definieren Sie eine Struktur s_date mit folgenden Feldern: - `int my_day` - `int my_month` - `int my_year` - `char my_name[100]`; 2. definieren Sie eine struct-Variable my_s_date. Initialisieren Sie die Struktur auf Inhalte Ihrer Wahl . Geben Sie die Struktur am Bildschirm aus 3. Beschreiben Sie die Felder der struct-Variable my_s_date und geben Sie diese am Bildschirm aus 4. definieren Sie einen Pointer auf die obige Struktur und beschreiben Sie die Struktur über den Pointer mit anderen Werten Geben Sie die Struktur wieder am Bildschirm aus, aber diesmal über den Pointer ! ## 3. Malloc Programmieren Sie ein kurzes Programm 1. reservieren Sie mit malloc Platz für 60 short-Variablen übernehmen Sie den Speicher mit der Pointervariablen \"short_ptr\" 2. beschreiben Sie die ersten drei Elemente über den \"short_ptr\" 3. beschreiben Sie die nächsten drei Elemente über einen \"temp_ptr\", den Sie nach jedem Schreibzugriff inkrementieren temp_ptr++; 4. beschreiben Sie die nächsten drei Elemente über den \"short_ptr\" in der ARRAY-Schreibweise 5. geben Sie die ersten 12 Elemente über eine Scheife aus 6. geben Sie den reservierten Speicher wieder frei ",
    "url": "/ece-ip-uebungen/ip2/pointer-strukturen/",
    "relUrl": "/ip2/pointer-strukturen/"
  },"12": {
    "doc": "Übung 13 - Dynamischer Stack",
    "title": "Übung 13 - Dynamischer Stack",
    "content": "# Übung 13 - Dynamischer Stack ## Aufgabenstellung Ersetzen Sie den Stack der Übung 12 (Postfix Auswertung) durch einen dynamischen Stack. Anforderungen an den dynamischen Stack: - die Interfaces des Stacks (push und pop) bleiben ident, sodass der Tausch des Stacks keine Änderungen der beiden Übungen notwendig macht - Ein Stack Element soll mithilfe eines \"struct\" realisiert werden - Bei Hinzufügen eines Elements am Stack wird dynamisch ein Stack Element im Speicher reserviert (malloc) - Bei Entfernen eines Elements vom Stack wird das entfernte Stack Element im Speicher wieder frei gegeben (free) ",
    "url": "/ece-ip-uebungen/ip2/dynamischer-stack/",
    "relUrl": "/ip2/dynamischer-stack/"
  },"13": {
    "doc": "Übung 14 - Pointer und Strukturen",
    "title": "Übung 14 - Pointer und Strukturen",
    "content": "# Übung 14 - Pointer und Strukturen ## Pointer.c Erstellen Sie 1 File: pointer.c ### Pointer 1 - Definieren Sie eine Variable mit dem Typ unsigned short und weisen Sie diesem einen Wert (> 300) zu - Definieren Sie einen pointer mit dem Typ unsigned char\\* und zeigen Sie mit diesem auf dem unsigned short Wert (type cast notwendig!) - Geben Sie den Wert der unsigned short Variable mittels Pointer am Bildschirm aus. ### Pointer 2 - Definieren Sie einen pointer mit dem Typ unsigned short\\* und zeigen Sie mit diesem auf den unsigned short Wert - Geben Sie den Wert der unsigned short Variable mittels Pointer am Bildschirm aus. ### Pointer 3 - Definieren Sie eine Struktur Data, mittels typedef, die - ein unsigned char array mit Länge 4 ODER - 4 unsigned char Variablen beinhaltet (ACHTUNG: diverse IDE machen mit dieser Variante Probleme => siehe ANMERKUNG) - Definieren Sie eine Variable vom Typ Data und weisen Sie den Variablen Werte zu. - Zeigen Sie mit dem vorhin definierten unsigned char Pointer auf die Elemente dieser Struktur - Geben Sie die Werte der Struktur Variablen Data mithilfe des Pointers am Bildschirm aus - `*(ptr+1)` ODER - `ptr++`; `*ptr` ... - **ANMERKUNG**: LabWin CVI verwehrt den Zugriff auf vier einzelne unsigned char Elemente der Struktur über inkrementieren des Pointers ptr ### Pointer 4 - Definieren Sie einen Pointer auf die struct Data - Geben Sie die Werte der vorhin definierten Struktur Variablen Data mithilfe des Pointers am Bildschirm aus ## Strukturen.c Erstellen Sie 1 File: strukturen.c ### Strukturen 1 - Definieren Sie folgende Strukturen mittels typedef - `s_dataset` bestehend aus: - firstname (Text: 50 Zeichen) - surname (Text: 50 Zeichen) - date_of_birth (struct s_date) - `s_date` bestehend aus: - day (unsigned char) - month (unsigned char) - year (unsigned int) - Definieren Sie ein Array mit 4 Elementen von s_dataset und befüllen Sie dieses mit Daten - Definieren Sie einen Pointer vom Typ `s_dataset*` (z.B. `ptr1`) und geben Sie mithilfe des Pointers die Daten am Bildschirm aus - Defnieren Sie einen Pointer auf einen \"`s_dataset*` Pointer\" (Pointer auf Pointer !) (z.B. `pptr2`) mit dem Sie auf den vorherigen Pointer (`ptr1`) zeigen - Geben Sie die Daten des Arrays mithilfe der beiden Pointer aus. Dabei soll die Ausgabe am Bildschirm nur mit dem `pptr2` gemacht werden und der `ptr1` soll auf die einzelnen s_dataset's zeigen. ### Strukturen 2 - Verwenden Sie die typedef Strukturen `s_dataset` und `s_date` aus dem letzten Beispiel - Definieren Sie einen Pointer auf `s_dataset` - Allokieren Sie mithilfe von malloc den Speicher für `s_dataset` - Befüllen Sie die \"Variable\" mit Daten und geben Sie diese am Bildschirm aus - Geben Sie den Speicher mit free wieder frei ### Strukturen 3 - Erweitern Sie die Struktur s_dataset aus dem letzten Beispiel und geben Sie ihr den Namen s_dataset2_struct (verwenden Sie diesmal kein typedef). - fügen Sie zusätzlich einen Pointer auf s_dataset2 \"next_element\" in der Struktur ein - `s_dataset2_struct` bestehend aus: - firstname (Text: 50 Zeichen) - surname (Text: 50 Zeichen) - date_of_birth (`struct s_date`) - next_element (`struct s_dataset2_struct*`) - Definieren Sie einen Pointer auf `struct s_dataset2_struct` mit dem Namen `start_ptr` - Definieren Sie einen Pointer auf `struct s_dataset2_struct` mit dem Namen `act_ptr` - Allokieren nach und nach Speicher für ein struct s_dataset2_struct Element (insgesamt 3x) - Befüllen Sie dabei einige Daten mit Werten - Bilden Sie eine einfach verkettete Liste, indem `start_ptr` auf das erste Element zeigt und ein nachfolgendes Element an den `next_element` Pointer des vorigen Elements gehängt wird. - geben Sie alle verketteten Elemente auf den Bildschirm aus - verwenden Sie hierzu eine while-Schleife (Achtung: wie erkennen Sie das Ende der verketteten Liste?) - verwenden Sie act_ptr, um auf die einzelnen Elemente zuzugreifen - Geben Sie den Speicher aller Elemente mit free wieder frei ",
    "url": "/ece-ip-uebungen/ip2/pointer-strukturen-2/",
    "relUrl": "/ip2/pointer-strukturen-2/"
  },"14": {
    "doc": "Übung 15 - Sortieralgorithmen",
    "title": "Übung 15 - Sortieralgorithmen",
    "content": "# Übung 15 - Sortieralgorithmen ## Aufgabenstellung Es soll mittels Insert Sort Algorithmus ein Array von integer Zahlen sortiert werden. Anforderungen an den Sortieralgorithmus - Erstellen Sie ein main.c file - aus der main.c können verschiedene Sortieralgorithmen aufgerufen werden, von denen wir vorerst einen programmieren - Das zu sortierende Zahlenarray ist wie folgt zu definieren: - `int sort_array[] = {92,4,6,7,252,4,83,5,49,10,134,156,7,29};` - Die Größe des Arrays soll per sizeof Funktion festgestellt werden - es ist eine Funktion `sort(...)` zu erstellen, der folgende Parameter mitgegeben werden - ein per enum definierter Wert, welcher Sortieralgorithmus angewendet werden soll - Pointer auf das zu sortierende Array - Länge des Arrays - main ruft die Sortieralgorithmen über `sort(...)` auf - `sort(...)` misst die Laufzeit des aufgerufenen Sortieralgorithmus und gibt diese aus - Erstellen sie eine insertsort.c und insertsort.h Datei - Die insertsort.c Datei enthält die Funktion insertSort, welcher das zu sortierende Array übergeben wird. Die Funktion sortiert das Array nach dem Insertionsort Algorithmus und gibt die Zahlen sortiert aus ## Dynamisch erzeugtes Array mit Zufallszahlen Wer möchte, kann sich über den unten verlinkten code dynamisch ein array mit Zufallszahlen erzeugen lassen. Die Arraygröße kann mit einem DEFINE eingestellt werden. ```c #define ARRAY_SIZE 1000000 ``` Das dynamisch erzeugte Array heißt `number_array` und ist vom Typ `unsigned long` [Arraygenerator mit Zufallszahlen](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/15-sortieralgorithmen/vorlage) ## Erweiterung - zusätzlicher Sortieralgorithmus Erweitern Sie Ihre Software um einen zusätzlichen Sortieralgorithmus. Der neue Algorithmus (eigenes .c und .h file) soll in das bestehende Programm eingebunden werden. Die Übergabe der Parameter, sowie die Ausgabe des Ergebnisses und eine eventuelle Zeitmessung ist wie in obiger Übung (Main - Modul) beschrieben umzusetzen. Alle Studierenden, die in der Vorlesung einen Sortieralgorithmus präsentiert haben, setzen bitte diesen Algorithmus um. Jedes Gruppenmitglied schreibt einen eigenen Code. Bitte unterschiedliche Implementierungen umsetzen (rekursiv/iterativ) Alle anderen Studierenden programmieren den Algorithmus, den wir gemeinsam vereinbart haben (siehe Einteilung). ### Im WIKI zur Verfügung stellen Zusätzlich zur Übungsabgabe stellen Sie bitte Ihren Sortieralgorithmus für alle im \"WIKI-Sortieralgorithmen\" bereit. Legen Sie Ihr zip-File, bestehend aus .c und .h File (ohne main), unter der jeweiligen Überschrift ab. Achtung: Filenamen und Funktionsaufruf sollen eindeutig sein (inkludieren Sie zB Ihren Nachnamen) ## Erweiterung - Testen von Funktionen Erweitern Sie Ihr Programm folgend: - Zu Beginn wählen Sie das zu sortierende Array aus. Es soll möglich sein, aus folgenden Optionen zu wählen: - vordefiniertes zu sortierendes Array - zufällig generiertes Zahlenarray mit/ohne Duplikaten - Eingabemöglichkeit Anzahl der Elemente - Anlegen einer Kopie des Arrays - Sortieren Sie das Array in in ein weiteres \"sorted\"-Array (verwenden Sie dafür den Sortieralgorithmus Ihrer Wahl) - Binden Sie mindestens 10 weitere Sortieralgorithmen in Ihr Programm ein - plus zusätzlich einen Standard-Sortieralgorithmus (zB aus stdlib.h ) - Führen Sie ALLE Sortieralgorithmen hintereinander aus - Referenz-Array kopieren - Zeitmessung starten - Array sortieren - Zeitmessung stoppen - Array mit dem \"sorted\"-Array vergleichen - Zusammenfassung anzeigen (PASS / FAIL, verstrichene Zeit) - Anzeige evtl in Farbe ### Anmerkung: - verwenden Sie für die verschiedenen Sortieralgorithmen ein ENUM in einer switch-case Struktur - die einzelnen Sortieralgorithmen können innerhalb einer Schleife, die NUM_SORTING_ALGORITHMS mal durchlaufen wird gestartet werden ",
    "url": "/ece-ip-uebungen/ip2/sortieralgorithmen/",
    "relUrl": "/ip2/sortieralgorithmen/"
  },"15": {
    "doc": "Übung 16 - Binärbaum + AVL Baum",
    "title": "Übung 16 - Binärbaum + AVL Baum",
    "content": "# Übung 16 - Binärbaum + AVL Baum ## Binärbaum Programmieren Sie für einen geordneter Binärbaum folgende Operationen: - hinzufügen eines Knoten: int insertNode(int value) - Suchen eines Knoten: `struct node* searchNode(int value)` - löschen eines Knoten: int deleteNode(int value) - bis auf die Funktion searchNode liefern die Funktionen über den Rückgabewert den Erfolg der Ausführung zurück. - 0 ... Ausführung fehlgeschlagen (zB Knoten beim Einfügen bereits vorhanden) - 1 ... Ausführung erfolgreich - Inhalte des Baums sortiert ausgeben: `int printDataSorted(struct node*)` - rekursive \"in order\" Traversierung - gibt die Zahlen des Baums sortiert aus - Verifikation des Baums: `int debugPrint(struct node*)` - rekursive Funktion (order egal) - Gibt von jedem Knoten den Wert, den Wert des Vaters und den Wert der Söhne aus. - Diese Funktion dient zur Verifikation der Baumverbindungen - Baum ausgeben: `int printTree(int)` - gibt den Baum als Baum mit Verästelungen aus. - Der Wert, der als Parameter übergeben wird, wird im Baum (falls vorhanden) rot ausgegeben. - [Beispielprogramm](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/16-binaer-avl-baum/vorlage) - beispielhafte Ausgabe siehe unten - Baum frei geben: `int destroyTree( struct node *)` - gibt zuerst alle Blätter und Knoten frei, zuletzt die Wurzel - (rekursive \"post order\" Traversierung) Die Rückgabewerte der Funktionen geben jeweils Auskunft über den Erfolg der Operation. Der Speicher der Knoten soll bei Einfügen in den Baum dynamisch allokiert werden. Zum Testen der Software werden obige Funktionen sequentiell mit entsprechenden Parametern aufgerufen. (siehe Abschnitt Testdaten) Für die Struktur eines Knoten ist folgender oder ähnlicher Code zu verwenden: ```c struct node { int value; struct node *parent; struct node *left_child; struct node *right child; }; struct node *wurzel; ``` Beispielhafte Ausgabe der Funktion printTree() ### Testdaten 1. Testdatensatz - Einfügen von: 1, 5, 3, 10, 8, 11, 6, 9, 7 - Ausgabe des Baums - suche 1 - suche 6 - suche 7 - suche 2 2. Testdatensatz - Einfügen von: 1, 5, 3, 10, 8, 11, 6, 9, 7 - Ausgabe des Baums - suche 9 - lösche 9 - suche 9 - Ausgabe des Baums 3. Testdatensatz - Einfügen von: 1, 5, 3, 10, 8, 11, 6, 9, 7 - Ausgabe des Baums - lösche 10 - suche 8 - Ausgabe des Baums - lösche 5 - suche 7 - Ausgabe des Baums 4. Testdatensatz - lösche 5 - suche 7 - Einfügen von: 1, 5, 3, 10, 8, 11, 6, 9, 7 - Ausgabe des Baums - suche 7 - lösche 5 - suche 7 - lösche 6 - suche 7 - suche 9 - Ausgabe des Baums - Baum löschen - Ausgabe des Baums ",
    "url": "/ece-ip-uebungen/ip2/binaer-avl-baum/",
    "relUrl": "/ip2/binaer-avl-baum/"
  },"16": {
    "doc": "Übung 17 - Sequentielle, binäre und Interpolationssuche",
    "title": "Übung 17 - Sequentielle, binäre und Interpolationssuche",
    "content": "# Übung 17 - Sequentielle, binäre und Interpolationssuche Schreiben Sie ein Programm, das aus einem sortierten Zahlen-Array eine bestimmte Zahl sucht. Die jeweilige Zahl ist mit vier Suchimplementationen (drei Such-Arten) zu suchen. - sequentielle Suche - binäre Suche (interativ programmiert) - binäre Suche (rekursiv programmiert) - Interpolationssuche (iterativ oder rekursiv) ## Detailbeschreibung: Zu Beginn gibt der Benutzer eine Anzahl von Zahlen ein (zB 1.000 oder 1.000.000) Die Software allokiert Speicher für diese Anzahl an integer Zahlen und befüllt diese mit zufälligen Integer Werten Das Array wird mit einem beliebigen Sortieralgorithmus sortiert (letzte Übung) Anschließend wird eine bestimmte (eingegebene) Zahl mithilfe der vier Suchalgorithmen gesucht Die Suche soll mit einer anderen Zahl wiederholt werden können. Dabei ist je Algorithmus die Anzahl der durchgeführten Schritte, sowie das Ergebnis (gefunden / nicht gefunden) auszugeben. ### Anmerkung: Damit Sie sich zu Beginn auf die Suchalgorithmen konzentrieren können, verwenden Sie die beigestellten Dateien, die 2000 kommagetrennte Integer Werte beinhalten. ### Formel zur Bestimmung des nächsten Index (Interpolationssuche) **mit** - $$x =$$ gesuchter Wert - $$W[i] =$$ Wert mit dem index $$i$$ - $$l,r =$$ Index - $$x =$$ gesuchter Index [Array Generator](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/17-suchalgorithmen/vorlage) [Datensatz](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/17-suchalgorithmen) ",
    "url": "/ece-ip-uebungen/ip2/suchalgorithmen/",
    "relUrl": "/ip2/suchalgorithmen/"
  },"17": {
    "doc": "Übungen für IP2",
    "title": "Übungen für IP2",
    "content": "# Übungen für IP2 ",
    "url": "/ece-ip-uebungen/ip2",
    "relUrl": "/ip2"
  },"18": {
    "doc": "Übungen für IP1",
    "title": "Übungen für IP1",
    "content": "# Übungen für IP1 ",
    "url": "/ece-ip-uebungen/ip1",
    "relUrl": "/ip1"
  }
}
