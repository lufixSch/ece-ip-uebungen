{"0": {
    "doc": "Übung 1 - Sonderzeichen",
    "title": "Übung 1 - Sonderzeichen",
    "content": "Hey ",
    "url": "/ece-ip-uebungen/ip1/sonderzeichen/",
    "relUrl": "/ip1/sonderzeichen/"
  },"1": {
    "doc": "Übung 2 - Datum und Uhrzeit",
    "title": "Übung 2 - Datum und Uhrzeit",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/datum-uhrzeit/",
    "relUrl": "/ip1/datum-uhrzeit/"
  },"2": {
    "doc": "Übung 3 - Funktionen und Operatoren - Binäre Darstellung",
    "title": "Übung 3 - Funktionen und Operatoren - Binäre Darstellung",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/binaere-darstellung/",
    "relUrl": "/ip1/binaere-darstellung/"
  },"3": {
    "doc": "Übung 4 - Mittelwertbildung",
    "title": "Übung 4 - Mittelwertbildung",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/mittelwertbildung/",
    "relUrl": "/ip1/mittelwertbildung/"
  },"4": {
    "doc": "Übung 5 - Arduino Übung - Blink",
    "title": "Übung 5 - Arduino Übung - Blink",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/blink/",
    "relUrl": "/ip1/blink/"
  },"5": {
    "doc": "Übung 6 - Arduino Übung - Parksensor",
    "title": "Übung 6 - Arduino Übung - Parksensor",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/parksensor/",
    "relUrl": "/ip1/parksensor/"
  },"6": {
    "doc": "Übung 7 - Arduino Übung - Rollosteuerung",
    "title": "Übung 7 - Arduino Übung - Rollosteuerung",
    "content": " ",
    "url": "/ece-ip-uebungen/ip1/rollosteuerung/",
    "relUrl": "/ip1/rollosteuerung/"
  },"7": {
    "doc": "Übung 8 - Filter",
    "title": "Übung 8 - Filter",
    "content": "# Übung 8 - Filter ## Übungsinhalte - Arrays - Kontrollstrukturen - Tastatureingabe - lesen aus einer Datei und schreiben in eine Datei - Coding Style ## Begriffe in diesem Zusammenhang Abtasttheorem nach Shannon, Filterkern, Faltung, Glättung ... ## Aufgabenstellung Schreiben Sie ein Programm, das Daten aus einem File einliest und anschließend filtert und wieder ausgibt. Bei den Daten handelt es sich um 640 char-Zahlenwerte, die einen \"verrauschten\" sinusförmigen Verlauf darstellen. (siehe „sinus-6.txt“) Nach Einlesen der Daten soll der Benutzer aufgefordert werden, eine Filterbreite einzugeben. Die Filterbreite repräsentiert die Anzahl der Werte, über die jeweils gleitend der Mittelwert gebildet wird. Gültige Werte für die Filterbreite sind von 1 bis 64. Analysieren Sie die Auswirkung verschiedener Filterbreiten, in dem Sie die gefilterten Daten in Excel visualisieren. Dokumentieren Sie ihre Erkenntnisse und begründen Sie. [zu filternde Rohdaten](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/08-filter) ## Detailanforderungen - Das Programm soll bei Start eine Beschreibung ausgeben, was vom Benutzer erwartet wird und was das Programm tun wird - Vom Benutzer eingegebener Text wird ausgewertet. Wenn es sich um eine Zahl handelt, muss der „Zahlentext“ in eine Zahl umgewandelt werden. Die eingegebene Zahl stellt die zu verwendende Filterbreite dar. Prüfen Sie den eingegebenen Wert auf Plausibilität (gültige Werte: 1 bis 64) - Filtern Sie die Daten durch Faltung mit dem besprochenen Filterkern - Schreiben Sie die gefilterten Daten in eine Datei, die Sie in Excel importieren/öffnen können (.csv) - vergleichen Sie das Ergebnis verschiedener Filterbreiten und stellen Sie diese grafisch in einem Excel Dokument dar - Beschreiben Sie Ihre Beobachtungen im Excel Dokument - welcher Filter liefert einen sauberen Sinusverlauf in den gefilterten Daten - Was beobachten Sie in den gefilterten Daten mit steigender Filterbreite und warum? (Amplitude, Phasenverschiebung, ...) - Abzugeben ist der Sourcecode als c-File, sowie die Excel Datei (.xlsx) # Allgemeine Vorgehensweise - Inhalt der Übung verstehen - Aufgabe in Teilaufgaben zerlegen + Struktur erstellen - Teilaufgaben einzeln lösen + TESTEN - Allgemein - Übersichtlichkeit -> Einrückung - Kommentare - sprechende Namen für Variablen und Funktionen verwenden + „coding style“ - Variablen … int dies_ist_eine_variable; - Funktionen … int diesIstEineFunktion(); - Achtung – in der Hauptschleife des Programms: - es gibt weniger output samples als input samples # Codeauszug (bitte verwenden) ```c #define NUM_SAMPLES 640 #define MAX_KERNELSIZE 64 // char beispiel_daten[4] = { 1, -4, 0, 18 }; char input_data[NUM_SAMPLES] = { #include \"sinus-6.txt\" }; // Inputdaten … sind zu filtern char output_data[NUM_SAMPLES]; // Outputdaten … //…hier wird das Ergebnis abgelegt char filter_kernel_size; // Filterbreite für den Filtervorgang // Schreiben in eine Datei // File schreiben vorbereiten FILE \\*input_file; // deklarieren des file-pointers „input_file“ input_file = fopen(\"Ausgabe.csv\",\"w\"); // öffnen der zu beschreibenden Datei // Schreiben in die Datei – zu verwenden wie „ printf “ fprintf(input_file ,\" Dieser Text wird %i mal in die Datei geschrieben\", 1); // nachdem alle Daten geschrieben wurden - Datei schließen fclose(input_file); ``` ",
    "url": "/ece-ip-uebungen/ip2/filter/",
    "relUrl": "/ip2/filter/"
  },"8": {
    "doc": "Übung 9 - Damenproblem",
    "title": "Übung 9 - Damenproblem",
    "content": "# Übung 9 - Damenproblem ## Themenbeschreibung Das Damenproblem ist eine schachmathematische Aufgabe. Es sollen jeweils acht Damen auf einem Schachbrett so aufgestellt werden, dass keine zwei Damen einander nach den Schachregeln schlagen können. Die Figurenfarbe wird dabei ignoriert, und es wird angenommen, dass jede Figur jede andere angreifen könnte. Oder anders ausgedrückt: Es sollen sich keine zwei Damen die gleiche Reihe, Linie oder Diagonale teilen. Im Mittelpunkt steht die Frage nach der Anzahl der möglichen Lösungen. Das Problem kann auf Schachbretter beliebiger Größe verallgemeinert werden. Dann gilt es, n nicht-dominierende Damen auf einem Brett von n x n Feldern zu positionieren. Für n = 8 hat das Damenproblem 92 verschiedene Lösungen. Betrachtet man Lösungen als gleich, die sich durch Spiegelung oder Drehung des Brettes auseinander ergeben, verbleiben noch zwölf Lösungen. Eine Lösung des Damnproblem mit Brettgröße 8x8 Die folgende Tabelle führt die Anzahl der eindeutigen Lösungen und die der gesamten Lösungen bis zur Brettgröße 26×26 auf: | **n** | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 12 | 14 | 16 | 20 | 25 (Weltrekord - 2005) | 26 (Weltrekord - 2009) | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------ | ------- | ---------- | -------------- | ---------------------- | ---------------------- | eindeutig | 1 | 0 | 0 | 1 | 2 | 1 | 6 | 12 | 46 | 92 | 1.787 | 45.752 | 1.846.955 | 4.878.666.808 | 275.986.683.743.434 | 2.789.712.466.510.289 | insgesamt | 1 | 0 | 0 | 2 | 10 | 4 | 40 | 92 | 352 | 724 | 14.200 | 365.596 | 14.772.512 | 39.029.188.884 | 2.207.893.435.808.352 | 22.317.699.616.364.044 | # Programmieraufgabe Im ersten Schritt suchen wir gemeinsam eine intuitive Lösung und setzen diese in einem C-Programm um. Besonderes Augenmerk liegt diesmal in der Trennung zwischen Datenstruktur und Algorithmus. Subroutinen sollen sauber in eigene Funktionen gekapselt werden. Zum Beispiel soll das \"Setzen\" einer Dame oder das \"Löschen\" einer Dame in einer eigenen Funktion formuliert werden. Wir werden die \"Ordnung\" der Lösung besprechen und in einem zweiten Schritt einen zweiten, optimierten Lösungsweg besprechen und umsetzen. Ziel ist es, nur Teile des Programmes - nämlich die Datenstruktur - auszutauschen, um den zweiten Lösungsweg umzusetzen. Die Rechenzeit für eine Lösung wird mit dem zweiten Lösungsweg dramatisch niedriger sein. Während des Lösungsfindung soll das Programm - die Zeit zur Lösungsfindung messen - die Anzahl der aufgetretenen \"Konflikte\" zählen - die Anzahl der \"Lady removes\" zählen - **Optional** sollen statt nur einer Lösung ALLE möglichen Lösungen gefunden werden. Das Programm soll zumindest aus folgenden Funktionen bestehen: - setLady ... platziert eine Dame an der aktuellen Position - verifyConflict ... überprüft, ob an der aktuellen Position ein Konflikt (Bedrohung durch eine andere Dame) vorhanden ist - removeLady ... entfernt die zuletzt gesetzte Dame - printChessBoard ... gibt das n\\*n Schachbrett am Bildschirm aus Dieses Diagramm veranschaulicht die Rechenzeit zum finden EINER Lösung mit unserem Algorithmus mit dem intuitiven Algorithmus (orange) und der optimierten Datenstruktur (blau). Auf der Abszisse ist die Brettgröße aufgetragen. [Vorlagen](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/09-damenproblem/vorlage) ## Mögliche Ausgabe: ```bash ... Solution: 91 00x00000 0000x000 0x000000 00000000 00000x00 000x0000 000000x0 x0000000 Solution: 92 00x00000 00000x00 000x0000 0x000000 00000000 0000x000 000000x0 x0000000 92 Solutions found. Board Size: 8 counted collisions: 19736 collision overflows: 0 counted lady removes: 2057 lady remove overflows: 0 counted solutions: 92 Max countervalue: 4294967295 End Time: 0.220000 seconds ``` ",
    "url": "/ece-ip-uebungen/ip2/damenproblem/",
    "relUrl": "/ip2/damenproblem/"
  },"9": {
    "doc": "Übung 10 - Damenproblem Smart",
    "title": "Übung 10 - Damenproblem Smart",
    "content": "# Übung 10 - Damenproblem Smart Programmieren Sie das Damenproblem so um, dass es die besprochene Smart-Datenstruktur verwendet. Verwenden Sie eindimensionale Arrays für die Position der Damen (Spaltenvektor) und die Markierung der Strahlen (Zeilenvektor, Hauptdiagonalen- und Nebendiagonalenvektor) Der Algorithmus des Programms bleibt ident. Strukturieren Sie den Programmcode so, dass Sie nur ihre Subfunktionen für die Änderung der Datenstruktur anpassen müssen. zB: - Kollissionsprüfung - Dame setzen - Dame löschen Die Ordnung des Programmes sinkt wie besprochen von O($$n^4$$) auf O($$n^3$$). Die Ausführungszeit bei großen Brettgrößen sinkt dramatisch. Vergleichen Sie die Rechenzeiten beider Programme für EINE Lösung der Brettgrößen 31 oder 32. Teilen Sie mir die Ausführungszeiten mit. Das Programm soll wahlweise ALLE bzw. EINE Lösung finden können (Präprozessorschalter oder Benutzereingabe zur Laufzeit) Bei ALLEN Lösungen soll (zumindest) die Anzahl der Lösungen und bei EINER Lösung die Lösung selbst dargestellt werden. Des weiteren soll die Laufzeit gemessen und die Anzahl der \"Konflikte\" und \"lady removes\" gezählt und ausgegeben werden ",
    "url": "/ece-ip-uebungen/ip2/damenproblem-smart/",
    "relUrl": "/ip2/damenproblem-smart/"
  },"10": {
    "doc": "Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung)",
    "title": "Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung)",
    "content": "# Übung 11 - Auswertung von Postfix Ausdrücken (UPN Auswertung) ## Aufgabenstellung - Zu Schreiben ist ein Programm, welches Ausdrücke, die in Postfix-Notation gegeben sind, auswertet. - umzusetzten ist ein Algorithmus, welcher gemeinsam besprochen wird - Die Ausdrücke sind in Form eines konstanten Strings gegeben. zB `const char INPUT*STR[ ] = “3,13,4,5,*,+,4,6,+,*,+“;` - Die Zahlen können auch mehrstellig sein, sind aber auf positive Integerwerte beschränkt - Geben sie das berechnete Ergebnisses am Bildschirm aus - Der notwendige Stack und dessen Zugriffsroutinen sind in gesonderten Files (stack.c, stack.h) zu programmieren. - Auf den Stack wird mittels folgender Funktionen zugegriffen: `int push(int operand)` und `int pop(int *operand)` - Der return-Wert gibt dabei jeweils Information über den Erfolg der Operation (0...ok, -1...Fehler) - Der Stack ist mit Hilfe eines Arrays umzusetzten - Die Stackgröße ist mittels #define einzustellen: #define STACK_SIZE 5 - Folgende Operatoren sind umzusetzen: +, -, \\*, /, - Die Funktionen push, pop müssen eine Fehlerbehandlung für die Fälle (a) leerer Stapel und (b) voller Stapel haben - Ausgabe einer Fehlermeldung, sollte der Ausdruck nicht gültig sein [Postfix Basis](https://github.com/lufixSch/ece-ip-uebungen/tree/main/ip2/12-upn-auswertung/vorlage) ### Optionale Umsetzung - Einlesen des Inputstrings von der Tastatur - setzen Sie zusätzlich folgende Operatoren um: mod, -(Vorzeichen), ^, max, min wobei für max und min folgendes gilt: - der erste operand (=parameter), gibt die Anzahl der Werte, von denen das Maximum oder das Minimum bestimmt wird, an. d.h. die Funktionen max, min können beliebig viele Operanden haben. Die Operandenanzahl 1 ist ungültig. Hat die max oder min Funktion weniger Operanden als erwartet, so ist dafür eine Fehlerbehandlung zu implementieren. - lassen Sie auch Floatwerte zu ## Testdaten | INFIX | POSTFIX | ---------------------------------- | -------------------------------------------- | $$( 13 + 4 ) * 5$$ | 13 , 4 , + , 5 , \\* | $$13 + 4 * 5$$ | 13 , 4 , 5 , \\* , + | $$13 * 4 + 5$$ | 13 , 4 , \\* , 5 , + | $$( 13 * 4 + 5) * ( 2 – 1 ) + 3$$ | 13 , 4 , \\* , 5 , + , 2 , 1 , - , \\* , 3 , + | $$1 + ( 13 + 4 * 5 ) * 10$$ | 1 , 13 , 4 , 5 , \\* , + , 10 , \\* , + | $$((13 + 4) * 5 ) + (13 + 4 * 5)$$ | 13, 4, +, 5, \\*, 13, 4, 5, \\*, +, + | ",
    "url": "/ece-ip-uebungen/ip2/upn-auswertung/",
    "relUrl": "/ip2/upn-auswertung/"
  },"11": {
    "doc": "Übung 12 - Wiederholung Pointer und Strukturen",
    "title": "Übung 12 - Wiederholung Pointer und Strukturen",
    "content": "# Übung 12 - Widerholung Pointer und Strukturen Dies ist eine Zusammenstellung kleinerer Aufgaben zur Widerholung von Pointern und Strukturen. # Aufgabenstellung zur Wiederholung von Inhalten ## 1. Pointer Schreiben Sie folgendes kurzes Programm: 1. definieren Sie eine char Variable \"my_char\" und einen Pointer \"ptr_to_char\" Setzen Sie die char-Variable über den Pointer auf den Wert 33; 2. definieren Sie eine int Variable \"my_int\" und einen Pointer \"ptr_to_int\" Setzen Sie die int-Variable über den Pointer auf den Wert 1234; Geben Sie beide Variablen über die Variable selbst und über den zugehörigen Pointer am Bildschirm aus. ## 2. Strukturen Programmieren Sie ein kurzes Programm 1. Definieren Sie eine Struktur s_date mit folgenden Feldern: - `int my_day` - `int my_month` - `int my_year` - `char my_name[100]`; 2. definieren Sie eine struct-Variable my_s_date. Initialisieren Sie die Struktur auf Inhalte Ihrer Wahl . Geben Sie die Struktur am Bildschirm aus 3. Beschreiben Sie die Felder der struct-Variable my_s_date und geben Sie diese am Bildschirm aus 4. definieren Sie einen Pointer auf die obige Struktur und beschreiben Sie die Struktur über den Pointer mit anderen Werten Geben Sie die Struktur wieder am Bildschirm aus, aber diesmal über den Pointer ! ## 3. Malloc Programmieren Sie ein kurzes Programm 1. reservieren Sie mit malloc Platz für 60 short-Variablen übernehmen Sie den Speicher mit der Pointervariablen \"short_ptr\" 2. beschreiben Sie die ersten drei Elemente über den \"short_ptr\" 3. beschreiben Sie die nächsten drei Elemente über einen \"temp_ptr\", den Sie nach jedem Schreibzugriff inkrementieren temp_ptr++; 4. beschreiben Sie die nächsten drei Elemente über den \"short_ptr\" in der ARRAY-Schreibweise 5. geben Sie die ersten 12 Elemente über eine Scheife aus 6. geben Sie den reservierten Speicher wieder frei ",
    "url": "/ece-ip-uebungen/ip2/pointer-strukturen/",
    "relUrl": "/ip2/pointer-strukturen/"
  },"12": {
    "doc": "Übung 13 - Dynamischer Stack",
    "title": "Übung 13 - Dynamischer Stack",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/dynamischer-stack/",
    "relUrl": "/ip2/dynamischer-stack/"
  },"13": {
    "doc": "Übung 14 - Pointer und Strukturen",
    "title": "Übung 14 - Pointer und Strukturen",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/pointer-strukturen-2/",
    "relUrl": "/ip2/pointer-strukturen-2/"
  },"14": {
    "doc": "Übung 15 - Sortieralgorithmen",
    "title": "Übung 15 - Sortieralgorithmen",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/sortieralgorithmen/",
    "relUrl": "/ip2/sortieralgorithmen/"
  },"15": {
    "doc": "Übung 16 - Binärbaum + AVL Baum",
    "title": "Übung 16 - Binärbaum + AVL Baum",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/binaer-avl-baum/",
    "relUrl": "/ip2/binaer-avl-baum/"
  },"16": {
    "doc": "Übung 8 - Sequentielle, binäre und Interpolationssuche",
    "title": "Übung 8 - Sequentielle, binäre und Interpolationssuche",
    "content": " ",
    "url": "/ece-ip-uebungen/ip2/suchalgorithmen/",
    "relUrl": "/ip2/suchalgorithmen/"
  },"17": {
    "doc": "Übungen für IP2",
    "title": "Übungen für IP2",
    "content": "# Übungen für IP2 ",
    "url": "/ece-ip-uebungen/ip2",
    "relUrl": "/ip2"
  },"18": {
    "doc": "Übungen für IP1",
    "title": "Übungen für IP1",
    "content": "# Übungen für IP1 ",
    "url": "/ece-ip-uebungen/ip1",
    "relUrl": "/ip1"
  }
}
